# -*- coding: utf-8 -*-
"""Baitaplon

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G45qM1DO_xecdoycF2lrcRe19xlAL_oP
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn import metrics
from sklearn.metrics import roc_curve
from sklearn.metrics import recall_score, confusion_matrix, precision_score
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.ensemble import AdaBoostClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score, accuracy_score, classification_report
from sklearn.tree import DecisionTreeClassifier
from sklearn import model_selection
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

from google.colab import files
uploaded = files.upload()

income_df= pd.read_csv('adult.csv')
income_df.head()

income_df.shape

income_df.describe()

income_df['income']=income_df['income'].map({'<=50K': 0, '>50K': 1})

income_df.info()

print(income_df.isnull().sum())
print(income_df.dtypes)

income_df.sample(5)

income_df = income_df[(income_df != '?').all(axis=1)]

income_df.head()

#Kiểm tra ngoại lệ
#Các tính năng số và phân loại riêng biệt
num_cols = pd.DataFrame (income_df, columns= ['age', 'educational-num', 'capital-gain', 'capital-loss', 'hours-per-week','fnlwgt', 
                                       'income'])
cat_cols = pd.DataFrame (income_df, columns= ['workclass', 'education', 'marital-status','occupation','relationship','race','gender','native-country'])

numerical_columns = list(income_df.loc[:,['age', 'capital-gain', 'capital-loss', 'hours-per-week', 
                                       'income']])
categorical_columns = list(income_df.loc[:,['workclass', 'education', 'marital-status','occupation','relationship','race','gender','native-country']])

sns.catplot(x='educational-num',y='income',data=income_df,kind='bar',height=6)
plt.show()

plt.figure(figsize=(38,14))
sns.countplot(x='native-country',data=income_df)
plt.show()

income_df['marital-status']=income_df['marital-status'].map({'Married-civ-spouse':'Married', 'Divorced':'Single', 'Never-married':'Single', 'Separated':'Single', 
'Widowed':'Single', 'Married-spouse-absent':'Married', 'Married-AF-spouse':'Married'})

rcParams['figure.figsize'] = 12, 12
income_df[['age', 'fnlwgt', 'educational-num', 'capital-gain', 'capital-loss', 'hours-per-week']].hist()

plt.matshow(income_df.corr())
plt.colorbar()
plt.xticks(np.arange(len(income_df.corr().columns)), income_df.corr().columns.values, rotation = 45) 
plt.yticks(np.arange(len(income_df.corr().columns)), income_df.corr().columns.values) 
for (i, j), corr in np.ndenumerate(income_df.corr()):
    plt.text(j, i, '{:0.1f}'.format(corr), ha='center', va='center', color='white', fontsize=14)

plt.figure (figsize = (12, 7), dpi = 100)
heatmap = sns.heatmap (income_df.corr()[['income']].sort_values (by = 'income', ascending = False), vmin = -1, vmax = 1, annot = True, cmap = 'GnBu')
heatmap.set_title ('Các tính năng tương quan với income', fontdict = {'fontsize':12}, pad = 18);

income_df.drop(['fnlwgt'], axis = 1, inplace = True)

dataset=income_df.copy()

dataset['age'] = pd.cut(dataset['age'], bins = [0, 25, 50, 100], labels = ['Young', 'Adult', 'Old'])

sns.countplot(x = 'income', hue = 'age', data = dataset)

dataset['Capital Diff'] = dataset['capital-gain'] - dataset['capital-loss']
dataset.drop(['capital-gain'], axis = 1, inplace = True)
dataset.drop(['capital-loss'], axis = 1, inplace = True)

dataset['Capital Diff'] = pd.cut(dataset['Capital Diff'], bins = [-5000, 5000, 100000], labels = ['Minor', 'Major'])
sns.countplot(x = 'income', hue = 'Capital Diff', data = dataset)

dataset['Hours per Week'] = pd.cut(dataset['hours-per-week'], 
                                   bins = [0, 30, 40, 100], 
                                   labels = ['Lesser Hours', 'Normal Hours', 'Extra Hours'])

sns.countplot(x = 'income', hue = 'Hours per Week', data = dataset)

sns.countplot(x = 'income', hue = 'workclass', data = dataset)

sns.countplot(x = 'income', hue = 'education', data = dataset)

income_df.drop(['educational-num'], axis = 1, inplace = True)
income_df['education'].replace(['11th', '9th', '7th-8th', '5th-6th', '10th', '1st-4th', 'Preschool', '12th'],
                             ' School', inplace = True)
income_df['education'].value_counts()

sns.countplot(x = 'income', hue = 'education', data = income_df)

plt.xticks(rotation = 45)
sns.countplot(x = 'income', hue = 'occupation', data = dataset)

sns.countplot(x = 'income', hue = 'race', data = dataset)

income_df['race'].unique()
income_df['race'].replace(['Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],' Other', inplace = True)

count = dataset['native-country'].value_counts()
count

plt.bar(count.index, count.values)
plt.xlabel('Countries')
plt.ylabel('Count')
plt.title('Count from each Country')

countries = np.array(dataset['native-country'].unique())
countries = np.delete(countries, 0)

dataset['native-country'].replace(countries, 'Other', inplace = True)
income_df['native-country'].replace(countries, 'Other', inplace = True)

sns.countplot(x = 'native-country', hue = 'income', data = dataset)

X = income_df.drop(['income'], axis=1)
Y = income_df['income']

X.head()

from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.3, random_state = 0)

df_tree = income_df.copy()

df_tree.head()

#Workclass
income_df["workclass"].replace("Private", 0, inplace=True)


income_df["workclass"].replace("Local-gov", 1, inplace=True)


income_df["workclass"].replace("Self-emp-not-inc", 2, inplace=True)
print("- Chuyển giá trị Self-emp-not-inc của cột workclass thành 2")

income_df["workclass"].replace("Self-emp-inc", 3, inplace=True)


income_df["workclass"].replace("Federal-gov", 4, inplace=True)


income_df["workclass"].replace("State-gov", 5, inplace=True)


income_df["workclass"].replace("Without-pay", 6, inplace=True)


#Education
income_df["education"].replace("HS-grad", 1, inplace=True)


income_df["education"].replace("Some-college", 2, inplace=True)


income_df["education"].replace("Bachelors", 3, inplace=True)


income_df["education"].replace(" School", 4, inplace=True)


income_df["education"].replace("Masters", 5, inplace=True)


income_df["education"].replace("Assoc-voc", 6, inplace=True)


income_df["education"].replace("Assoc-acdm", 7, inplace=True)


income_df["education"].replace("Prof-school", 8, inplace=True)


income_df["education"].replace("Doctorate", 9, inplace=True)

#Marital-status

income_df["marital-status"].replace("Single", 0, inplace=True)

income_df["marital-status"].replace("Married", 1, inplace=True)

#Native-country

income_df["native-country"].replace("United-States", 0, inplace=True)

income_df["native-country"].replace("Other", 1, inplace=True)

#Race

income_df["race"].replace("White", 0, inplace=True)

income_df["race"].replace(" Other", 1, inplace=True)

#Gender

income_df["gender"].replace("Male", 0, inplace=True)

income_df["gender"].replace("Female", 1, inplace=True)

#Relationship

income_df["relationship"].replace("Husband", 0, inplace=True)

income_df["relationship"].replace("Not-in-family", 1, inplace=True)

income_df["relationship"].replace("Own-child", 2, inplace=True)

income_df["relationship"].replace("Unmarried", 3, inplace=True)

income_df["relationship"].replace("Wife", 4, inplace=True)

income_df["relationship"].replace("Other-relative", 5, inplace=True)

#Occupation

income_df["occupation"].replace("Craft-repair", 0, inplace=True)

income_df["occupation"].replace("Prof-specialty", 1, inplace=True)

income_df["occupation"].replace("Exec-managerial", 2, inplace=True)

income_df["occupation"].replace("Adm-clerical", 3, inplace=True)

income_df["occupation"].replace("Sales", 4, inplace=True)

income_df["occupation"].replace("Other-service", 5, inplace=True)

income_df["occupation"].replace("Machine-op-inspct", 6, inplace=True)

income_df["occupation"].replace("Transport-moving", 7, inplace=True)

income_df["occupation"].replace("Handlers-cleaners", 8, inplace=True)

income_df["occupation"].replace("Farming-fishing", 9, inplace=True)

income_df["occupation"].replace("Tech-support", 10, inplace=True)

income_df["occupation"].replace("Protective-serv", 11, inplace=True)

income_df["occupation"].replace("Priv-house-serv", 12, inplace=True)

income_df["occupation"].replace("Armed-Forces", 13, inplace=True)

count = income_df['education'].value_counts()
count

df_tree['age'] = df_tree['age'].astype(str)
df_tree['workclass'] = df_tree['workclass'].astype(str)
df_tree['marital-status'] = df_tree['marital-status'].astype(str)
df_tree['occupation'] = df_tree['occupation'].astype(str)
df_tree['relationship'] = df_tree['relationship'].astype(str)
df_tree['race'] = df_tree['race'].astype(str)
df_tree['gender'] = df_tree['gender'].astype(str)
df_tree['capital-gain'] = df_tree['capital-gain'].astype(str)
df_tree['capital-loss'] = df_tree['capital-loss'].astype(str)
df_tree['hours-per-week'] = df_tree['hours-per-week'].astype(str)
df_tree['income'] = df_tree['income'].astype(str)

X = df_tree.drop('income', axis=1)
y = df_tree['income'].values.reshape(-1, 1)

print ('X:', X.shape,'\ny:', y.shape)

# Array of test size value from 0.2 to 0.3
test_size = np.arange(start=0.2, stop=0.35, step= 0.05)

# Khởi tạo danh sách nơi sẽ lưu trữ điểm của từng kích thước bài kiểm tra
score =[]
for size in test_size:
    X_train, X_test, y_train, y_test = train_test_split (X, y, test_size=size, random_state=0)
    DT_Clf = DecisionTreeClassifier (max_depth=3)
    DT_Clf.fit (X_train, y_train)
    score.append (DT_Clf.score (X_test, y_test))

# Tạo một khung dữ liệu để hiển thị kết quả
r= pd.DataFrame({'Test size': test_size , 'Score': score})
r.sort_values(by = ['Score'], ascending = False, inplace = True)
r.style.highlight_max(color='#acd9a8')
# => test size 0.3 có score lớn nhất

X_train, X_test, y_train, y_test = train_test_split (X, y, stratify=y, test_size = 0.3, random_state = 0)

print('kích thước X_train : ', X_train.shape)
print('kích thước X_test : ', X_test.shape)
print('kích thước y_train : ', y_train.shape)
print('kích thước y_test : ', y_test.shape)

# Khởi tạo mô hình
DT_model = DecisionTreeClassifier(max_depth=3)

# Lắp mô hình vào tập huấn luyện
DT_model.fit(X_train, y_train)

y_pred = DT_model.predict(X_test) #dự đoán x_test

print('Model accuracy score: {0:0.4f}'. format(accuracy_score(y_test, y_pred)))

print('Training set score: {:.4f}'.format(DT_model.score(X_train, y_train)))
print('Test set score: {:.4f}'.format(DT_model.score(X_test, y_test)))

# KFold
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.model_selection import KFold
#Xác thực chéo K-Fold
kf = KFold(n_splits=10, shuffle=False)

#Độ chính xác xác thực chéo
# Validation
from sklearn.model_selection import cross_val_predict
from sklearn.model_selection import cross_val_score
# Metrics
from sklearn import metrics
from sklearn.metrics import confusion_matrix, auc, roc_curve
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.metrics import PrecisionRecallDisplay, RocCurveDisplay
from sklearn.metrics import ConfusionMatrixDisplay, classification_report
from statistics import stdev
score = cross_val_score(DT_model, X_train, y_train, cv=kf, scoring='accuracy')
DT_model_cv_score = score.mean()
DT_model_cv_stdev = stdev(score)
print('Điểm số Độ chính xác của Xác thực chéo là:\n {}'.format(score))

Accuracy  = ['Độ chính xác xác thực chéo']
DT_A = pd.DataFrame({'CV Mean':DT_model_cv_score,'Std':DT_model_cv_stdev},index=Accuracy )
DT_A

ConfusionMatrixDisplay.from_estimator(DT_model, X_test, y_test, colorbar=False, cmap='Reds')
plt.title('Ma trận nhầm lẫn của  Decision Tree')
plt.grid(False)

print(classification_report(y_test, y_pred))

def metrics_calculator(y_test, y_pred, model_name):
    
    #Hàm này tính tất cả các chỉ số hiệu suất mong muốn cho một mô hình nhất định.
    
    result = pd.DataFrame(data=[accuracy_score(y_test, y_pred),
                                precision_score(y_test, y_pred, average='macro'),
                                recall_score(y_test, y_pred, average='macro'),
                                f1_score(y_test, y_pred, average='macro')],
                          index=['Accuracy','Precision','Recall','F1-score'],
                          columns = [model_name])
    return result

DT_result = metrics_calculator(y_test, y_pred, 'Decision Tree')
DT_result

feature_names = X.columns
target_names = ["<=50K", ">50K"]

from sklearn.tree import DecisionTreeClassifier
from sklearn import tree
from sklearn import datasets
from IPython.display import Image
from sklearn import model_selection

import pydotplus
#
dot_data = tree.export_graphviz(DT_model, out_file=None,
                                feature_names=feature_names,
                                class_names=target_names)

graph = pydotplus.graph_from_dot_data(dot_data)
#
Image(graph.create_png())

import pandas as pd
#
feature_ipm = pd.Series(DT_model.feature_importances_, index=df_tree.columns.values[0:12]).sort_values(ascending=False)
feature_ipm

# Commented out IPython magic to ensure Python compatibility.
from ast import increment_lineno
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

sns.barplot(x=feature_ipm , y=feature_ipm.index)

plt.xlabel('Mức quan trọng ')
plt.ylabel('Tính năng')
plt.title('Trực quan hóa các tính năng')
plt.legend()
plt.show()

df_rf=income_df.copy()

from sklearn.model_selection import train_test_split
from sklearn import preprocessing
X = df_rf.drop('income', axis=1)
y = df_rf['income'].ravel()

test_size = np.arange(start=0.2, stop=0.35, step=0.05)

# Khởi tạo danh sách nơi sẽ lưu trữ điểm của từng kích thước bài kiểm tra
score = []
for size in test_size:
    X_train1, X_test1, y_train1, y_test1 = train_test_split (X, y, test_size=size, random_state=0)
    RF_model = RandomForestClassifier ()
    RF_model.fit (X_train1, y_train1)
    score.append (RF_model.score (X_test1, y_test1))
    
# Tạo một khung dữ liệu để hiển thị kết quả   
r= pd.DataFrame({'Test size': test_size, 'Score': score})
r.sort_values(by = ['Score'], ascending = False, inplace = True)
r.style.highlight_max(color='Purples')
# -> test size = 0.2 có score lớn nhất

X_train1, X_test1, y_train1, y_test1 = train_test_split(X, y, stratify=y, test_size = 0.2, random_state = 0)

print('kích thước X_train:', X_train1.shape)
print('kích thước X_test:', X_test1.shape)
print('kích thước y_train:', y_train1.shape)
print('kích thước y_test:', y_test1.shape)

# Khởi tạo mô hình
RF_model = RandomForestClassifier()

# Lắp mô hình vào tập huấn luyện
RF_model.fit(X_train1, y_train1)

y_pred = RF_model.predict(X_test1)

print('Model Accuracy Score: {0:0.4f}'. format(accuracy_score(y_test1, y_pred)))

print('Training set score: {:.4f}'.format(RF_model.score(X_train1, y_train1)))
print('Test set score: {:.4f}'.format(RF_model.score(X_test1, y_test1)))

kf = KFold(n_splits=10, shuffle=False)

score = cross_val_score(RF_model, X_train1, y_train1, cv=kf, scoring='accuracy')
RF_model_cv_score = score.mean()
RF_model_cv_stdev = stdev(score)
print('Cross Validation Accuracy scores are:\n {}'.format(score))

Accuracy = ['Độ chính xác xác thực chéo']
RF_A = pd.DataFrame({'CV Mean':RF_model_cv_score,'Std':RF_model_cv_stdev},index=Accuracy)
RF_A

print(classification_report(y_test1, y_pred))

RF_result = metrics_calculator(y_test1, y_pred, ' Random Forest')
RF_result

# code thử lại thuật toán RF
result = RF_model.predict([[25,0,4,0,6,2,1,0,0,0,40,0]])
if result.all() == 0:
  print("<=50K")
else:
    print(">50K")
# => RF đã đúng

Conclusion = pd.concat([DT_result, RF_result], axis=1)
Conclusion

df_rf

pr = income_df.groupby(['income'])
target = pr.describe(percentiles = [0.25, 0.5, 0.75])
target.style.background_gradient(cmap='Reds')